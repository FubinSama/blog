# 5. Redis的持久化

## RDB（Redis DataBase）

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存中

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用临时文件替换上次持久化好的文件。

整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需进行大规模数据的恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失

RDB保存的是`dump.rdb`文件，可以通过`config get dir`查看存储的位置

除了依靠配置的save规则dump外，当执行关闭redis和`flushall`时，也会进行一次dump。也可以通过`save`（保存时禁止写入）和`bgsave`（后台保存，此时可以写入）命令强制dump

### RDB优势

- 适合大规模的数据恢复
- 对数据的完整性和一致性要求不高

### RDB劣势

- 如果redis意外down掉，就会丢失最后一次快照后的所有修改
- fork时，内存中的数据被克隆了一份，会导致大致两倍的内存膨胀

## AOF（Append Only File）

**以日志的形式来记录每个写操作**，将Redis执行过的所有写指令记录下来，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

AOF保存的是`appendonly.aof`文件

AOF和RDB同时存在时，优先使用AOF

当AOF文件损坏时，可以使用`redis-check-aof --fix <.aof文件>`命令进行修复

### Rewrite

AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复的最小指令集，可以使用命令`bgrewriteaof`

#### 重写原理

AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后rename），遍历新进程的内存中数据，每条记录有一条的set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据用命令的方式重写到一个新的aof文件

#### 触发机制

Redis会记录上次重写时AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发

### AOF优势

- 每修改同步：appendfsync always
- 每秒同步：appendfsync everysec
- 不同步：appendfsync no

### AOF劣势

- 相同数据集的数据而言，aof文件要远大于rdb文件，恢复速度慢于rdb
- aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同

## 总结

- RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储
- AOF持久化方式记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，aof命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大
- 只做缓存：如果你希望你的数据在服务器运行的时候存在，也可以不使用任何持久化方式
- 同时开启两种持久化方式
  - 在这种情况下，当Redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整
  - RDB的数据不实时，同时使用两者时，服务器重启也只会找AOF文件。但作者建议不要只使用AOF，因为RDB更适用于备份数据库

## 性能建议

因为RDB文件只用作后备用途，建立只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留`save 900 1`这条规则。

如果启用AOF。AOF重写的基础大小默认值64M太小了，可以设置到5G以上。默认超过原大小100%大小时重写，可以改到适当的数值

如果不启用AOF，紧靠Master-Slave Replication实现高可用性也是可以的。可以省掉一大笔IO，也减少了rewrite带来的系统波动。代价是如果Master/Slave同时宕机，会丢失十几分钟的数据，启动脚本也会比较Master和Slave中的RDB文件，载入较新的那个
