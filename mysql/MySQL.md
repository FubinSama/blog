# wfb's MySQL笔记

- [wfb's MySQL笔记](#wfbs-mysql笔记)
  - [存储引擎](#存储引擎)
    - [MyISAM](#myisam)
    - [InnoDB](#innodb)
  - [字符集和校对规则](#字符集和校对规则)
    - [字符集和校对规则的选用](#字符集和校对规则的选用)
    - [校对规则](#校对规则)
  - [索引](#索引)
    - [哈希索引](#哈希索引)
    - [BTree索引](#btree索引)
    - [索引使用](#索引使用)
    - [不建议使用索引的情况](#不建议使用索引的情况)
  - [数据同步中的Binlog](#数据同步中的binlog)
  - [事务机制](#事务机制)
    - [关系数据库遵循的ACID规则](#关系数据库遵循的acid规则)
    - [事务隔离级别](#事务隔离级别)
    - [锁机制](#锁机制)
      - [按锁的粒度划分](#按锁的粒度划分)
      - [共享锁和排他锁](#共享锁和排他锁)

## 存储引擎

### MyISAM

- MySQL5.5之前的默认引擎
- 不支持事务和外键
- 不支持行锁
- 不支持崩溃后的安全恢复
- 对于不会进行修改的表，支持压缩表，极大地减少了磁盘空间占用
- 采用非聚簇索引
- 适合读密集型的表
- 在数据库主从分离的情况下，经常被用作主库的存储引擎

### InnoDB

- MySQL5.5之后的默认引擎
- 支持事务和外键
- 支持行锁，采用MVCC来支持高并发，有可能死锁
- 支持崩溃后的安全恢复
- 采用聚簇索引
- 适合写密集型的表

## 字符集和校对规则

在创建数据库、数据表的时候会指定 __character__ 和 __collate__ 。如下：

```SQL
CREATE DATABASE db_name DEFAULT CHARSET SET utf8 COLLATE utf8_general_ci;

CREATE TABLE `NOTE`(
    `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
    `content` varchar(128) CHARSET utf8 COLLATE utf8_bin NOT NULL COMMENT '内容', --对某一个字段设置字符集和校对规则
    PRIMARY KEY(`id`)
) ENGING=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
```

- __字符集__：一种从二进制编码到某类字符符号的映射。
- __校对规则__：某种字符集下的排序规则

### 字符集和校对规则的选用

- 如果存储的内容是 __英文字符等拉丁语系字符__，则使用默认的 __latin1__ 编码即可
- 如果存储的内容是 __汉字、俄文、阿拉伯语等费拉丁语系字符__，则建议使用 __utf8__ 字符集，其校对规则如下：
  - utf8_general_ci：utf8的默认校对规则。不支持扩展，仅能够在字符之间进行诸葛比较，因此比较速度很快
  - utf8_unicode_ci：根据UCA（Unicode校对规则算法）执行，支持扩展，即可以把一个字母看作与其他字母组合相等。
  - utf8_bin：将字符串每个字符用二进制数据编译存储，区分大小写，而且可以存二进制的内容
- 如果数据库 __需要支持emoji字符__，那么字符集选用 __utf8mb4__，并使用utf8mb4_bin作校对规则

### 校对规则

- ___cs__：大小写敏感的方式比较字符串
- ___ci__：大小写不敏感的方式比较字符串
- ___bin__：用字符串编码的二进制形式比较

## 索引

MySQL索引使用的数据结构主要有BTree索引和哈希索引

### 哈希索引

- 底层数据结构为哈希表。
- 在绝大多数需求为单条记录查询时，可以选择使用哈希索引

### BTree索引

MySQL中的BTree索引使用的是B+树

- MyISAM：B+Tree叶节点存放的是数据记录的地址。在索引检索时，首先按照B+Tree搜索算法搜索索引，找到地址，然后以该地址查找记录。
- InnoDB：主键索引为聚簇索引，其余索引为辅助索引，辅助索引data域存储响应记录主键的值。在根据辅助索引搜索时，先找到对应的主键，在用主键索引查找。

### 索引使用

```SQL
explain select * from test_user where id = 1;
```

这里注意type、key和extra这三列：

- type：显示了连接使用了那种类型，有无使用索引。如果为ALL，那么说明要进行全表扫描
- key：此列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键为NULL
- Extra：此列如果出现Using filesort（需要额外的步骤来发现如何对返回的行排序）或者Using temporary（需要创建一个临时表来存储结果），说明查询需要优化

1. 最左前缀原则：如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此索引就可以被用到。如联合索引（name,city），有以下SQL语句：
   1. `select * from user where name=xxx and city=xxx; --- 可以命中索引`
   2. `select * from user where name=xxx; ---可以命中索引`
   3. `select * from user where city=xxx; ---无法命中索引`
2. where子句中对子段事假函数，会导致无法命中索引。如`select * from test where to_date(create_time) > xxxxx;`，会导致无法命中create_time的索引
3. 在使用InnoDB时应使用与业务无关的自增主键，即使用逻辑主键，而不要使用业务主键
4. 合理利用索引覆盖：索引覆盖只一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要聚集索引中的记录。当实现了覆盖索引的时候，explain命令的Extra会显示using Index
5. 避免冗余索引：冗余索引指的是索引的功能相同，能够命中A就肯定能命中B，那么A就是冗余索引。如(name,city)和(name)，(name)是冗余索引，可以删除。
6. 将打算加索引的列设置为 __NOT NULL__，否则将导致引擎放弃使用索引而进行全表扫描
7. 删除长期未使用的索引。可以通过`select * from sys.schema_unused_indexes where object_schema='数据库名';`，查看该数据库未被使用的索引
8. 联表查询必须存在的情况下，可以使用索引提高性能。联表索引使用要注意如下两点
   1. 确保 __ON__ 和 __USING__ 中的列上有索引。当表A和表B通过列c关联时，如果优化器关联的顺序是A、B，则只需要在B的c列上建立索引
   2. 确保任何的 __GROUP BY__ 和 __ORDER BY__ 中的表达式只涉及一个表中的列。这样MySQL才有可能使用索引来优化
9. 在使用limit offset查询缓慢时，可以借助索引来提高性能
10. 查询条件应使用正确的数据类型，否则MySQL会自动做类型转换，导致无法命中索引

### 不建议使用索引的情况

1. 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引
2. 索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值

## 数据同步中的Binlog

MySQL中的Binlog是用来做POINT-IN-TIME的回复和主从复制的，由数据库上层生成，是SQL执行的逻辑日志，在事务提交完成后进行一次写入。其有三种格式：

1. __Statement__：MySQL的默认Binlog格式。记录执行的语句。产生的日志比价少，能够节省I/O和存储资源，日志具有较高的可阅读星。但其需要在记录语句信息的同时记录语句执行的上下文信息
2. __Row__：日志中会记录每一行数据被修改的形式。其不需要记录语句执行的上下文信息，但是需要记录每一条记录的改动，因此当受影响的记录很多时，日志量会非常大
3. __Mixed__：以上两种的结合。会根据执行的每一条具体的SQL语句来区别对待记录的日志形式，也就是在Statement和Row之间选择一种

## 事务机制

### 关系数据库遵循的ACID规则

1. A（Atomic）原子性：即事务要么全部做完，要么全部都不做。只要其中一个操作失败，就认为事务失败，需要回滚
2. C（Consistency）一致性：数据库要一直处于一致的状态
3. I（Isolation）独立性：并发的事务之间不会互相影响
4. D（Durability）持久性：一旦事务提交后，它所做的修改将会永久地保存在数据库中

### 事务隔离级别

1. 未授权读取（Read Uncommitted）：会产生脏读，可以读取未提交的记录，实际情况下不会使用
2. 授权读取（Read committed）：会存在不可重复读以及幻读的现象。不可重复读重点在修改，即读取过的数据两次读的值不一样；幻读则侧重于记录数据变化，多次执行同一个查询返回的记录不完全相同
3. 可重复读（Repeatable Read）：解决了不可重复读的问题，会存在幻读现象。InnoDB使用MVCC+Gap Lock避免了幻读问题
4. 串行（Serializable）：也称可串行读，此级别下读操作会隐式获取共享锁，保证不同事务间的互斥。其消除了脏读、幻读，但事务并发度急剧下降

### [锁机制](https://www.cnblogs.com/leedaily/p/8378779.html)

#### 按锁的粒度划分

- 表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗较少，加锁快，不会出现死锁。触发锁冲突的概率最高，并发度最低。MyISAM和InnoDB引擎都支持表级锁
- 行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。InnoDB支持的行级锁如下：
  - Record Lock：对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项
  - Gap Lock：对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行
  - Next-key Lock：锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合，可解决幻读问题

#### 共享锁和排他锁

- 共享锁（S）：又被称为读锁，是读取操作创建的锁。可以使用`SELECT ... LOCK IN SHARE MODE`来强制获取共享锁，否则绝大多数查询操作不会获取锁（串行事务级别除外）
- 排他锁（X）：又被称为写锁，获取排他锁的事务既能读取数据也能修改数据。InnoDB对CUD（insert、update、delete）操作涉及的数据会默认加排他锁。对于查询操作可以通过`SELECT ... FOR UPDATE`加排他锁
- 意向共享锁（IS）：InnoDB专有的表级锁，表示事务准备给数据行加入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁
- 意向排他锁（IX）：InnoDB专有的表级锁，表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁

InnoDB的锁机制兼容表：

请求锁模式\当前锁模式|X|IX|S|IS
--|--|--|--|--
X|冲突|冲突|冲突|冲突
IX|冲突|兼容|冲突|兼容
S|冲突|冲突|兼容|兼容
IS|冲突|兼容|兼容|兼容
