# 支付网关

支付网关主要包括两部分逻辑：

1. 协议层——负责跟第三方打交道，将第三方api进行初步封装，给以上层更加统一化的结构。让上层尽可能的忽略第三方的协议实现细节（比如第三方使用的字符组织格式是json、xml、soap还是txt，schema是使用http、https还是sftp），转而操作实体对象和其方法。
2. 业务层——向外部暴露统一门面，对内通过路由策略选择使用的支付商，委托该支付商协议处理，记录交易信息，向外部提供交易查询等统一的业务功能。

## 协议层

对接某一家支付商时，第一步就是编写协议层，将该支付商的协议细节封装成类对象和方法调用。然后编写基本的测试用例，使用第三方文档上的例子和测试环境认证信息对协议层代码进行质量保证。协议层编写完成，就意味着我们在不考虑业务的情况下，可以在他们的测试环境跑通全部的出金（放款）和入金（还款）流程。

如果一家支付商可以支持多个国家，或者多个项目要接一家新的支付商时，协议层可以作为一个工具包进行导入，不在需要重复开发或者需要简单的扩展。

需要调用的其它内部模块的逻辑也可以封装成协议层。

支付网关向外部暴露的接口定义也可以封装到协议层。

对于协议层的单元测试，不需要严格的assert定义，如非必要也不需要在编译时执行。一般只有第三方要求更改协议，或者更改了协议层代码时需要手动跑一下。

## 业务层

业务层主要是跟公司内部的服务打交道。作为一个支付网关，其业务逻辑是很简单的，只需要为上层业务提供信息流变成资金流的途径。

主要需要考虑如下方面：

1. 尽可能对外部提供统一的入金和出金门面接口，使上层应用可以使用简单的api调用来完成信息流到资金流的转变
2. 在关键的地方做好幂等和防重复处理
3. 维护各个支付商的认证信息
4. 出金和入金的路由策略，通过路由策略选择合适的支付商或者让上层应用选择想要使用的支付商
5. 做好基本的风控验证。完整的风控应由上层模块处理，但支付网关仍需做简单的风控验证，比如向交易发起的模块确认交易来源正确，确定交易金额没有超过单笔交易限制等。
6. 基本的交易信息查询功能
7. 使用具体的支付商创建对应交易，并根据该支付商的特点做某些特定处理。

### 绑定账户和卡逻辑

1. 接收用户的账号信息
2. 如果该国家有账号验证逻辑，则进行账号验证。对于卡因为没有PCI认证，所以可能要从前端就将信息提交给第三方，后端只保存token。用户入金使用的卡必须要要这样干，因为要完整的卡四要素。但是我们出金时，只需要用户的卡号和身份证号，这时实际上我们是不需要满足PCI认证的，但是还是会有很多支付商把放款和还款逻辑写在一起，所以也需要在前端提交卡数据到第三方。
3. 对账户或卡的基本信息进行认证。账户主要是长度和格式。卡可能需要确认是信用卡还是储蓄卡
4. 存储绑卡数据。

出金时收款账户的核心数据：

1. bankCode / bankName
2. documentType & documentNumber
3. accountType & accountNumber

入金时打款卡的核心四要素：

1. bankCode / bankName
2. cardNumber
3. expire Year and Month
4. cvv

### 出金

出金核心业务逻辑为：

1. 异步接受出金请求
2. 进行风控校验
3. 进行注册或者验证账户逻辑
   1. 注册：某些银行需要对第一次打款的账户进行注册逻辑（一般与打款请求协议类似，只是打款金额为0），只有等几个小时后，银行对该账号完成注册后，才能发起实际的打款
   2. 账号验证：某些国家的银行是不进行身份认证的，此时需要先给这个账户跨行打一笔很小的金额，然后查询央行数据，通过这笔交易的受益人信息去和用户个人信息作比对，完成账号验证逻辑
   3. 实际打款：调用支付商的实际打款api，完成打款
4. 异步处理回调，进行状态变更，并告知上游系统交易最终状态
5. 主动向第三方查询交易，作为异步通知出问题时的补偿机制

### 入金

入金恶心业务逻辑为：

1. 获取支持的入金方式
2. 根据选择的入金方式去调用对应第三方
3. 向用户展示第三方页面或者我方页面
4. 等待用户完成还款
5. 跳转到我方状态页
6. 异步处理回调，进行状态变更，并告知上游系统交易最终状态
7. 主动向第三方查询交易，作为异步通知出问题时的补偿机制